#lang narscribblus/interactive

@typedef["WidgetDef" @dict[
  @key["name" #:required String]{
    A locally unique name for the widget.  Convention is to use single dashes
    to separate words, but it's really up to you.

    Names need to be unique within each domain's id space.  When you define
    a wmsy domain you do something like this:
    @js{
      var wmsy = require("wmsy/wmsy");
      var wy = new wmsy.WmsyDomain({id: "a", domain: "b"});
    }
    So your name needs to be unique for the given id and domain.
  }

  @key["doc" #:optional String]{
    A brief description of what your widget does for use by wmsy-aware tools.
    If your @lxref{name} already says it all, there's no need to provide this.
    Admittedly, at the current time no part of the framework surface this.
  }

  @key["constraint" #:required ConstraintDef]{}

  @group["Form"
    @key["structure" #:required StructureDefIsh]{}

    @key["style" #:optional WmsyStyleDef]{}
  ]

  @group["Function"
    @key["protoConstructor" #:optional @func[
      @args[
        @param[constraintBasis]
        @param[domNode DOMNode]{
          The DOM Node that the binding that is triggering this parameterization
          to occur will be bound onto.  This is provided strictly for debug
          purposes so that context can be provided for failures.
        }
      ]
    ]]{
    }

    @key["constructor" #:optional @func[
      @args[
        @param[constraintBasis]
        @param[domNode DOMNode]
      ]
    ]]{
    }

    @key["impl" #:optional @dict[
      @key["preInit" #:optional @func[@args[] @return[]]]{
      }

      @key["postInit" #:optional @func[@args[] @return[]]]{
      }

      @key["postInitUpdate" #:optional @func[@args[] @return[]]]{
      }

      @key["update" #:optional @func[
        @args[
          @param[aRecursive Boolean]{
            Should all nested widgets be updated as well?  Sub-widgets are
            always automatically updated.
          }
        ]
        @return[]
      ]]{
        The update function is responsible for updating the visual status of the
        widget to reflect the current state of the bound object.  This method is
        invoked only when wmsy is explicitly told to update a binding, in which
        case it may be invoked because of recursive notifications.

        You would want to implement this method if you do any custom
        manipulation of the DOM tree.  If you provide an implementation of this
        method, you must invoke __update on the binding before you return so
        that the built-in mechanisms still operate.  If you do not provide an
        implementation, __update will automatically be invoked.
      }

      @key["destroy" #:optional @func[
        @args[]
        @return[]
      ]]{
        Handles widget cleanup.  If you provide an implementation of this
        method, you must invoke __destroy on the binding before you return so
        that the built-in mechanisms still operate.  If you do not provide an
        implementation, __destroy will automatically be invoked.
      }
    ]]{
      All of the functions you put in here will end up exposed on your binding.
      There are a few well-known functions you may want to implement.
    }
  ]

  @group["Behaviour"

    @key["events" #:optional @dictof[
      @key["event name" String]{
      }
      @value["handler function" Function]{
      }
    ]]

    @key["focus" #:optional @oneof[
          WmsyExportDomain.focus.domain.horizontal
          WmsyExportDomain.focus.domain.vertical
          WmsyExportDomain.focus.container.horizontal
          WmsyExportDomain.focus.container.vertical
          WmsyExportDomain.focus.nestedItem.horizontal
          WmsyExportDomain.focus.nestedItem.vertical
          WmsyExportDomain.focus.item
        ]]{}
  ]

  @group["Widget Communication"
    @desc{
      Mechanisms to support loosely coupled widget communication; see 
    }

    @key["emit" #:optional @listof["signal name" String]{
    }]{
    }

    @key["receive" #:optional @dictof[
      @key["signal name" String]{
      }
      @value["handler function" Function]{
      }
    ]]{
    }

    @key["relay" #:optional @listof["signal name" String]{
    }]{
    }
  ]

  @key["provideContext" #:optional
    @dictof[
      @key["name"]
      @value["binding" BindingDef]
    ]
  ]

  @key["popups" #:optional @dictof[
    @key["popup name" String]
    @value["popup constraint" WmsyConstraintDef]]]{
    
  }
]]{
  The wmsy widget definition dictionary.
}

@typedef[StructureDefIsh @oneof[StructureDef ObjDecorator]]

@typedef[BindingDef @oneof[
  @case[String]{
    The name of an attribute on the bound object.
  }
  @case[@listof["attribute name"]]{
    A list of attributes to traverse starting from the bound object.
  }
  @case[ComputedValueDescriptor]{
    A value computed by invoking an impl-defined function on the binding.
  }
  @case[ImplDataDescriptor]{
    A value retrieved from the impl definition for the current widget.
  }
  @case[ConstraintValueDescriptor]{
    A value retrieved from the constraint dictionary.
  }
]]{
  
}

@typedef[StyleDef @dictof[
  @key["name" String]
  @value["value" @oneof[StyleDef StyleSubDef]]{
  }
]]

@typedef[StyleSubDef @dictof[
  @key["name" String]
  @value["value" @oneof[
    String
    @listof["css line" String]]
  ]
]]
